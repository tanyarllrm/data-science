---
title: 'Lab Report 1'
author: "Tanya Ralliaram"
geometry: margin=.75in
output:
  pdf_document: default
  word_document: default
  html_document:
    df_print: paged
    theme: cosmo
header-includes:
- \usepackage{graphicx}
- \usepackage{color}
graphics: yes
fontsize: 11pt
---

<!-- You can check templates from this website and change html theme: https://www.datadreaming.org/post/r-markdown-theme-gallery/ -->
<!-- It won't affect the PDF or Word. -->


## Question 1: Linear Regression


### 1.1. (10 pts) 

Give basic insights into your numeric variable you have picked as output variable using one categorical variable you selected. 

- What are the min / max values and median of the output variable, $Y$?
- What is median of the output value among different classes of the categorical variable you picked? You must use `group_by` and `summarize` functions.

### 1.2. (10 pts) 

Visualize the variables you selected.

- Draw histogram of the numeric variables you selected.
- Draw distribution of the output variable $Y$ with respect to the different classes of your categorical variable. The plot must somehow show the distributional differences among different classes. You can use boxplot, histogram, or other visuals (e.g. density ringes).

- Draw scatter plot between one of your numeric inputs and the output variable. Discuss whether the plot indicate a relation, if it is linear, if there are outliers? Feel free to remove the outlier. Feel free to transform the data.

```{r}
library('tidyverse')
spotify <- read.csv('data/spotify_songs.csv')
```

```{r}
spotify <- select(spotify,  c('track_id','energy', 'loudness', 'tempo', 'playlist_genre', 'danceability'))
rmarkdown::paged_table(spotify)
```

```{r}
dim(spotify)
```

### 1.3. (15 pts) 

Using the all dataset, fit a regression:

1. Using the one numeric input variable fit a simple regression model.

  - Write down the model.
	- Fit the regression line.
	- Summarize the output.
	- Plot the input and output variables in a scatter plot and add the predicted values as a line.
	- Interpret the results. Is it a good fit? Is your input variable good in explaining the outputs?


The linear regression equation is:
$$Y \sim \beta_0 + \beta_1 X_1 + \beta_2 X_2 + \beta_3 X_3$$
  	
Our linear regression model for one numeric input variable, tempo, is:
$$D_i = \beta_0 + \beta_1 Tempo_i+\epsilon_i$$
To fit the line:
```{r}
spotifyfit1 <- lm(danceability ~ tempo, data = spotify)
spotifyfit1
```

Summarize the output:
```{r}
summary(spotifyfit1)
```
  	
Based on the p-value, tempo is a significant factor in predicting danceability.

Plot the model:
```{r}
preds <- predict(spotifyfit1)
ggplot(spotify, aes(x=tempo, y=danceability)) + 
  geom_point(alpha=.2, size=2) + 
  geom_line(aes(y=preds), colour="red")
```
From the graph, we can see that there is a slight correlation between the input
variable 'tempo' and output 'danceability'. Generally speaking, until a tempo of
around 100-125 bpm, danceability appears to increase as tempo increases. After this,
danceability decreases as tempo increases. However, it is not significant enough alone
to determine danceability, as there is a high range of possible output values
for each tempo input.
  	
2. Using all your input variables, fit a multiple linear regression model

   - Write down the model
   - Fit the regression line and summarize the output
   - Interpret the results. Is it a good fit? Are the input variables good in explaining the outputs?

Our multiple linear regression model is:
$$D_i \sim \beta_0 + \beta_1 Tempo_i + \beta_2 Energy_i + \beta_3 Loud_i +\epsilon_i$$
We will fit the model and view the summary:
```{r}
spotifyfit2 <- lm(danceability ~ tempo + energy + loudness, data = spotify)
summary(spotifyfit2)
```

All three variables, tempo, energy, and loudness, appear to have a significant 
effect on danceability, however energy is a lesser factor than tempo and loudness.

Comparing the Mean Squared Error of both models, we get:
```{r}
sigma(spotifyfit1)
sigma(spotifyfit2)
```
Adding two more numerical variables slightly improved the MSE.

```{r, warning=F, message=F}
library('plotly')
preds <- predict(spotifyfit2)
g1 <- ggplot(spotify, aes(x=tempo, y=danceability)) + 
  geom_point(alpha=.3, size=1) + 
  geom_line(aes(y=preds), colour="blue")

ggplotly(g1)
```

Plotting the new fit on the same axes as the previous plot shows the difference
between a single and multivariable regression. We can see that there is more variation
in the plot of the fitting line where the graph is more dense and varied.

3. Now, do the same things as you did, but this time add an interaction between one categorical and one numeric variable.
   - Write down the model, fit to the data, summarize and interpret the results.

The model will now have the addition of the categorical variable playlist_genre.
$$D_i \sim \beta_0 + \beta_1 Tempo_i + \beta_2 Energy_i + \beta_3 Loud_i + \beta_4 Genre_i +\epsilon_i$$
   
The variable playlist_genre is a string, but we will ensure it is treated as a factor anyways
to avoid any errors.
```{r}
spotify$playlist_genre <- as.factor(spotify$playlist_genre)
```

```{r}
spotifyfit3 <- lm(danceability ~ tempo + energy + loudness + playlist_genre, data = spotify)
summary(spotifyfit3)$coefficients
```

The addition of playlist_genre produces some interesting results. We can see that
the rap and latin genres are clear deciding factors, with significantly lower p-values
than other genres. Conversely, R&B and pop have lower p-values, meaning that those genres
alone are not significant factors in danceability.
Additionally, after adding this new variable, the p-value for tempo is very low.

```{r}
library('ggExtra')
preds <- predict(spotifyfit3)
ggplot(spotify, aes(x=tempo, y=danceability, colour=playlist_genre)) + 
  geom_point(alpha=.2, size=1) + 
  geom_line(aes(y=preds), colour="red")
```

The MSE of all 3 models is:
```{r}
sigma(spotifyfit1)
sigma(spotifyfit2)
sigma(spotifyfit3)
```
Adding playlist_genre to the model reduced the error more so than when we added
the additional numerical variables.

4. Which model you fit is the best in predicting the output variable? Which one is the second and third best? Rank the models based on their performance.

In order of performance from best to worst, they are:
fit3 > fit 2 > fit 1

### 1.4. (15 pts) 

In this section, you will do the same you did in 1.3, but this time you will first split the data into train and test.

- Select seed to fix the random numbers you will generate using `set.seed(...)`. 
- Split your data into test and train sets with 20/80 test-train ratio. 
- Fit the model to the train set and evaluate the how well the model performed on test set.
- Which model performed the best on test set? Rank the models based ion their performance.
- Is the rank the same as the one you had in 1.3?

```{r}
set.seed(1)
train_size <- floor(0.8*nrow(spotify))
train_inds <- sample(1:nrow(spotify), size = train_size)
test_inds  <- setdiff(1:nrow(spotify), train_inds)

train <- spotify[ train_inds , ] 
test  <- spotify[ test_inds , ]

cat('train size:', nrow(train), '\ntest size:', nrow(test))
```

```{r}
library('caret')
trainfit1 <- lm(danceability ~ tempo, data = train)
#summary(trainfit1)$coefficients

trainfit2 <- lm(danceability ~ tempo + energy + loudness, data = train)
#summary(trainfit2)$coefficients

trainfit3 <- lm(danceability ~ tempo + energy + loudness + playlist_genre, data = train)
#summary(trainfit3)$coefficients

```

Apply to the test data:
```{r}
preds1 <- predict(trainfit1, newdata=test)
preds2 <- predict(trainfit2, newdata=test)
preds3 <- predict(trainfit3, newdata=test)
```

```{r}
rmse1 <- RMSE(preds1, test$danceability)
rmse2 <- RMSE(preds2, test$danceability)
rmse3 <- RMSE(preds3, test$danceability)

rmses <- c(rmse1,rmse2,rmse3)
rmses
sigma(spotifyfit1)
sigma(spotifyfit2)
sigma(spotifyfit3)
```
The models perform similarly to how they did on the full datasets. Model 3 is still
the best, followed by model 2 then model 3.
Comparing the individual models, the new Model 1 and 2 had slightly higher MSE,
but the new model 3 had a slightly lower MSE.


\pagebreak

## Question 2: Gradient Descent Algorithm (By hand)

In case you want to take a picture (screenshot) of your notebook (tablet), you can use the below lines to embed the image to the output PDF file:


```{r}
#knitr::include_graphics('conspiracy.jpg')
```





\pagebreak

## Question 3. Gradient Descent Algorithm


### 3.1. Get familiar

You will use horsepower as input variable and miles per gallon (mpg) as output:

1. Plot the scatterplot between `mpg` ($Y$) and `horsepower` ($X$).
    - Is the relationship positive or negative? Does mpg increase or reduce as horsepower increases?
    - Is the relationship linear?
2. Plot the scatterplot between `log(mpg)` and `log(horsepower)`.
    - Is the relationship positive or negative?
    - Is the relationship linear?
3. Which of the two versions is better for linear regression?

### 3.2. Fill in the code

The code below estimates the coefficients of linear regression using gradient descent algorithm. If you are given a single linear regression model;

$$Y = \beta_0 + \beta_1 X $$

where $Y=[Y_1,\dots,Y_N]^T$ and $X=[X_1,\dots,X_N]^T$ are output and input vectors containing the observations.

The algorithm estimates the parameter vector $\theta = [\beta_0,\beta_1]$ by starting with an arbitrary $\theta_0$ and adjusting it with the gradient of the loss function as:

$$\theta := \theta + \frac \alpha N X^T(Y - \theta X)$$

where $\alpha$ is the step size (or learning rate) and $(Y - \theta X)^T X$ is the gradient. At each step it calculates the gradient of the loss and adjusts the parameter set accordingly.

### 3.3. Run GDA


1. Run the code with the above parameters. How many iterations did it take to estimate the parameters?
2. Reduce epsilon to `1e-6`, set `alpha=0.05` run the code. 
    - How many iterations did it take to estimate the parameters?
    - Does the result improve? Why or why not?
3. Reduce alpha to `alpha=0.01`
   - How many iterations did it take?
   - Did the resulting line change? Why or why not?
4. Set alpha back to `alpha=0.05` and try `theta0=c(1,1)` vs. `theta0=c(1,-1)`:
   - How many iterations did it take? Which is less than the other?
   - Why starting with a negative slope have this effect?
5. Reduce epsilon to `epsilon = 1e-8` and try `alpha=0.01`, `alpha=0.05` and `alpha=0.1`.
   - What effect does alpha have on iterations and resulting fitted line?


